---
title: "回归分析"
author: "黄赫堂 2020201415"
date: "2024-12-18"
---
# 回归分析
## 加载包
```{r}
library(readxl)
library(dplyr)
library(writexl)
```

## 读取数据


```{r}
salary <- read_excel("data.xlsx")
summary(salary)
```

## 处理数据


```{r}
### 公司规模哑变量赋值

df1 <- data.frame(salary$公司规模)
df1 <- factor(df1, levels=c("100以下","100-499","500以上"))
dummy_scale <- model.matrix(~ salary$公司规模 - 1, data=salary)
salary <- cbind(salary, dummy_scale)
salary <- subset(salary,select = -公司规模)
```

```{r}
### 已有工作经验哑变量赋

df2 <- data.frame(salary$已有工作经验)
df2 <- factor(df2, levels=c("1年以内","1-3年","3-5年","5年以上","经验不限"))
dummy_experience <- model.matrix(~ salary$已有工作经验 - 1, data=salary)
salary <- cbind(salary, dummy_experience)
salary <- subset(salary,select = -已有工作经验)
```


```{r}
### 学历哑变量赋值

df3 <- data.frame(salary$学历)
df3 <- factor(df3, levels=c("本科","高中及以下","大专","研究生","学历不限"))
dummy_degree <- model.matrix(~ salary$学历 - 1, data=salary)
salary <- cbind(salary, dummy_degree)
salary <- subset(salary,select = -学历)
```

```{r}
### 融资阶段哑变量赋值

df4 <- data.frame(salary$学历)
df4 <- factor(df4, levels=c("不需要融资","准备融资","正在融资","已上市","未知"))
dummy_phase <- model.matrix(~ salary$融资阶段 - 1, data=salary)
salary <- cbind(salary, dummy_phase)
salary <- subset(salary,select = -融资阶段)
```

```{r}
### 福利哑变量赋值

salary <- salary %>% 
  mutate(福利 = case_when(
      福利 == TRUE ~ 1,
      福利 == FALSE ~ 0,
      TRUE ~ 福利
    ))
salary$福利 <- as.integer(salary$福利)
```

```{r}
### 位置哑变量赋值

df5 <- data.frame(salary$位置)
df5 <- factor(df5, levels=c("东部地区","中部地区","南部地区","西部地区","未知"))
dummy_location <- model.matrix(~ salary$位置 - 1, data=salary)
salary <- cbind(salary, dummy_location)
salary <- subset(salary,select = -位置)
```

```{r}
### 公司行业哑变量赋值

df6 <- data.frame(salary$公司行业)
df6 <- factor(df6, levels=c("金融互联网","公共服务","机械制造","媒体教培","商业服务"))
dummy_industry <- model.matrix(~ salary$公司行业 - 1, data=salary)
salary <- cbind(salary, dummy_industry)
salary <- subset(salary,select = -公司行业)
```

```{r}
### 职业类别哑变量赋值

df7 <- data.frame(salary$公司行业)
df7 <- factor(df7, levels=c("商务与工程类","法务与咨询类","媒体与培训类","销售与服务类","其他职业类"))
dummy_category <- model.matrix(~ salary$职业类别 - 1, data=salary)
### 处理表格
salary <- subset(salary,select = -职业类别)
salary <- subset(salary,select = - 职位)
salary <- subset(salary,select = - 年薪)
salary <- subset(salary,select = - `salary$公司规模100以下`)
salary <- subset(salary,select = - `salary$已有工作经验1年以内`)
salary <- subset(salary,select = - `salary$融资阶段未知`)
salary <- subset(salary,select = - `salary$位置东部地区`)
salary <- subset(salary,select = - `salary$公司行业金融互联网`)
salary <- subset(salary,select = - `salary$学历本科`)
colnames(salary) <- gsub("\\$", "_", colnames(salary))
```


## 保存处理后的数据


```{r}
# 保存处理后的数据
write_xlsx(salary, "data_variables.xlsx")
```


## 回归


```{r}
myfit0 <- lm(log_salary~., data=salary)
summary(myfit0)
```


### 残差图


```{r,message=FALSE,warning=FALSE,collapse=TRUE}
par(mfrow=c(2,2))
plot(myfit0,c(1:4))
par(mfrow=c(1,1))
```


### 异方差检验


#### Spearman Test



对每一个自变量$x_i$与残差的绝对值两两检验。


```{r,message=FALSE,warning=FALSE,collapse=TRUE}
p <- rep(1,ncol(salary))  # 初始化

for(i in 1:length(p)){
  if(colnames(salary)[i]!="log_salary"){
    p[i] <- cor.test(as.numeric(salary[,i]),abs(myfit0$residuals))$p.value
  }
}

names(p) <- colnames(salary)
p<=0.1
```

可见，存在$p<0.1$，即存在异方差问题。

> 注：书本只有一元回归的检验方法，此处增加了多元回归的异方差检验方法如下。



#### Breusch-Pagan Test


使用**Breusch-Pagan Test**进行检验[^1]。


$$H_0:\{模型myfit0不存在异方差现象\}$$

```{r,message=FALSE,warning=FALSE,collapse=TRUE}
library(lmtest)
bptest(myfit0)
```

由于$p<0.05$，于是在95%的置信水平下拒绝原假设，认为存在异方差问题。



### 自相关检验


#### 绘图


```{r,message=FALSE,warning=FALSE,collapse=TRUE}
n <- nrow(salary)
e_i1 <- myfit0$residuals[1:(n-1)]
e_i2 <- myfit0$residuals[2:n]

library(ggplot2)
ggplot()+
  geom_point(mapping = aes(x = e_i1,y = e_i2))+
  geom_vline(xintercept = 0,col="red",alpha=0.4)+
  geom_hline(yintercept = 0,col="red",alpha=0.4)+
  theme_classic()
```

点无规则地落在坐标原点四周，无明显规律性。


#### DW检验


```{r,message=FALSE,warning=FALSE,collapse=TRUE}
dwtest(myfit0,alternative = "two.sided")
```
  
可见，在95%置信水平下**拒绝**原假设。即认为存在一阶自相关性。

### 多重共线性检验


```{r}
cor(salary)
```

```{r,message=FALSE,warning=FALSE,collapse=TRUE}
library(car) 
alias(myfit0,complete = T)  # 完全多重共线性

sort(vif(myfit0),decreasing = T)  # 多重共线性

mean(vif(myfit0))
```

$\bar{VIF}$略大于1，说明存在多重共线性。


## 异方差的处理：对数回归模型


经尝试，**BOX-COX变换**和**加权回归**均未能解决异方差问题，而**对数回归模型**的方法能有效解决此处异方差问题


## 模型选择


采用**逐步回归**的方法，在不同的准则下选择变量。


### $R_{adjust}^2$准则


```{r}

library(leaps)
salary.r2adj <- leaps(x=salary[,-2],y=salary[,2],method="adjr2")
result <- cbind(salary.r2adj$which,adjRsq=salary.r2adj$adjr2)
optimal_model_index <- which.max(salary.r2adj$adjr2) 
optimal_model <- result[optimal_model_index, ] 
print(optimal_model)
```
最优模型包含所有变量


### AIC和BIC准则


```{r}
x <- salary[,-2]
y <- salary[,2]
salary.aic <- salary.bic <- NULL
for(j in 1:nrow(salary.r2adj$which)){
  x.subset <- as.matrix(x[salary.r2adj$which[j,]])
  lm.subset <- lm(y~x.subset)
  salary.aic <- c(salary.aic,AIC(lm.subset))
  salary.bic <- c(salary.bic,BIC(lm.subset))
}
# 找到最小 AIC 值的索引
min_aic_index <- which.min(salary.aic)

# 提取最小 AIC 值对应的自变量组合
min_aic_combination <- salary.r2adj$which[min_aic_index,]

# 获取最小 AIC 值
min_aic_value <- salary.aic[min_aic_index]

# 输出最小 AIC 值及其对应的自变量组合
cat("最小 AIC 值：", min_aic_value, "\n")
cat("最小 AIC 值对应的自变量组合：\n")
print(min_aic_combination)

# 找到最小 BIC 值的索引
min_bic_index <- which.min(salary.bic)

# 提取最小 BIC 值对应的自变量组合
min_bic_combination <- salary.r2adj$which[min_bic_index,]

# 获取最小 BIC 值
min_bic_value <- salary.bic[min_bic_index]

# 输出最小 BIC 值及其对应的自变量组合
cat("最小 BIC 值：", min_bic_value, "\n")
cat("最小 BIC 值对应的自变量组合：\n")
print(min_bic_combination)
```
最优模型包含所有变量


### $C_p$准则


```{r}
salary.cp <- leaps(x=salary[,-2],y=salary[,2],method="Cp")

# 找到最小 Cp 值的索引
min_cp_index <- which.min(salary.cp$Cp)

# 提取最小 Cp 值所在的自变量组合
min_cp_combination <- salary.cp$which[min_cp_index,]

# 获取最小 Cp 值
min_cp_value <- salary.cp$Cp[min_cp_index]

# 输出最小 Cp 值及其对应的自变量组合
cat("最小 Cp 值：", min_cp_value, "\n")
cat("最小 Cp 值对应的自变量组合：\n")
print(min_cp_combination)
```

最优模型包含所有变量


### 对比


在**AIC准则**、**BIC准则**和**$C_p$准则**之间，三者所选的变量相同，考虑到多重共线性并结合三个准则，确定模型为"myfit0"。


### 多重共线性分析


```{r,message=FALSE,warning=FALSE,collapse=TRUE}
sort(vif(myfit0),decreasing = T)  # 多重共线性

mean(vif(myfit0))
```

可见，$\bar{VIF}$未明显大于1，且$VIF_j<10$均成立，故可认为消除了多重共线性。


### 异方差检验


#### Breusch-Pagan Test

使用**Breusch-Pagan Test**进行检验[^1]。


$$H_0:\{模型myfit0不存在异方差现象\}$$

```{r,message=FALSE,warning=FALSE,collapse=TRUE}
library(lmtest)
bptest(myfit0)
```

在90%的置信水平下，无法拒绝原假设。即认为该模型不存在异方差问题。


### 自相关检验


#### DW检验


```{r,message=FALSE,warning=FALSE,collapse=TRUE}
dwtest(myfit0,alternative = "two.sided")
```
  
在90%的置信水平下，无法拒绝原假设。即认为该模型不存在自相关问题。


### 正态性检验


使用**Kolmogorov-Smirnov Test**检验模型残差的正态性。


```{r,message=FALSE,warning=FALSE,collapse=TRUE}
ks.test(myfit0$residuals,y = pnorm,mean(myfit0$residuals),sd(myfit0$residuals))

ggplot()+
  geom_density(mapping = aes(x = myfit0$residuals))+
  labs(title = "残差密度分布图",x="residuals")+
  theme_classic()+
  theme(plot.title = element_text(hjust = 0.5))
```


可见，在90%的置信水平下，无法拒绝原假设。即不可否认残差不服从正态分布。

残差密度分布图也体现了较好的正态性。


## 综上


至此，我们建立了不存在**自相关性**、不存在**异方差性**、不存在**多重共线性**且残差符合**正态性**假设的回归模型。


## 稳定性检测


下面，我们使用使用**Bootstrap法**检验不同法则下，所选变量以及模型的稳定性。


### 编写函数


```{r,message=FALSE,warning=FALSE,collapse=TRUE,cache=TRUE}
startBootstrap <- function(B,data0,select,Yname,selection,Choose){
  library(StepReg)
  
  # B为Bootstrap的次数；
  # select为筛选变量的方法；
  # data为数据表
  # Yname为Y变量名；
  # selection为回归方向
  # Choose为选择模型的标准
  
  TotalVariate <- colnames(data0)[colnames(data0)!=Yname]  # 所有X变量
  result <- data.frame(matrix(nrow = 0,ncol = ncol(data0)))  # 初始化result表，每一列为一个变量，每一行为一个模型，最后一列n记录频数
  
  n <- nrow(data0)  # 样本量
  
  for(i in 1:B){
    Asample_tmp <- sample(x = 1:n,size = n,replace = T)  # 有放回重抽样
    Asample <- data0[Asample_tmp,]  # 重抽样数据集
    Afit <- stepwise(data = Asample,y = Yname,selection = selection,select = select,Choose = Choose)
    
    chosenVariate <- Afit$variate[-1]  # 选出的变量，除去常数项
    
    variate_tmp <- is.element(TotalVariate,chosenVariate)  # 所选变量的位置
    
    model_tmp <- which(apply(X = result[,-ncol(result)],MARGIN = 1,FUN = function(x){sum(x!=variate_tmp)})==0)  # 若该模型出现过，返回所在行标
    
    if(setequal(model_tmp,integer(0))){
      # 如果model_tmp是integer(0)，即不存在该模型
      
      result <- rbind(result,c(variate_tmp,1))  # 增加该模型的记录
    }else{
      result[model_tmp,ncol(result)] <- result[model_tmp,ncol(result)]+1  # 记录+1
    }
    
  }
  
  colnames(result) <- c(TotalVariate,"n")
  
  result <- result[order(result[,ncol(result)],decreasing = T),]  # 按模型出现频数排序
  
  return(result)
}
```


### AIC法则


```{r,message=FALSE,warning=FALSE,collapse=TRUE,cache=TRUE}
set.seed(13)

AICmodels <- startBootstrap(B = 1000,data0 = salary,select = "AIC",Yname = "log_salary",selection = "bidirection",Choose = "AIC")

# 模型的分布为（根据所选变量分）
AICtable <- data.frame(frequncy=as.vector(table(rowSums(AICmodels[,-ncol(AICmodels)])))/1000,
                       complexity=as.numeric(names(table(rowSums(AICmodels[,-ncol(AICmodels)])))))
                       
ggplot(data = AICtable)+
  geom_histogram(mapping = aes(x = complexity,y = frequncy),stat = "identity",col="black",fill="lightblue")+
  theme_classic()+
  labs(title = "AIC选择模型分布图")+
  theme(plot.title = element_text(hjust = 0.5))


library(DT)
datatable(AICmodels,width = "100%",options = list(scrollX=T))
```



```{r,message=FALSE,warning=FALSE,collapse=TRUE,cache=TRUE}
variate_percent_AIC <- colSums(AICmodels[,-ncol(AICmodels)])/nrow(AICmodels)

datatable(data.frame(选入频率=variate_percent_AIC))
```


### BIC法则


```{r,message=FALSE,warning=FALSE,collapse=TRUE,cache=TRUE}
set.seed(13)

BICmodels <- startBootstrap(B = 1000,data0 = salary,select = "BIC",Yname = "log_salary",selection = "bidirection",Choose = "BIC")

# 模型的分布为（根据所选变量分）
BICtable <- data.frame(frequncy=as.vector(table(rowSums(BICmodels[,-ncol(BICmodels)])))/1000,
                       complexity=as.numeric(names(table(rowSums(BICmodels[,-ncol(BICmodels)])))))
                       
ggplot(data = BICtable)+
  geom_histogram(mapping = aes(x = complexity,y = frequncy),stat = "identity",col="black",fill="lightblue")+
  theme_classic()+
  labs(title = "BIC选择模型分布图")+
  theme(plot.title = element_text(hjust = 0.5))


datatable(BICmodels,width = "100%",options = list(scrollX=T))
```



```{r,message=FALSE,warning=FALSE,collapse=TRUE,cache=TRUE}
variate_percent_BIC <- colSums(BICmodels[,-ncol(BICmodels)])/nrow(BICmodels)

datatable(data.frame(选入频率=variate_percent_BIC))
```

### $C_p$法则


```{r,message=FALSE,warning=FALSE,collapse=TRUE,cache=TRUE}
set.seed(13)

CPmodels <- startBootstrap(B = 1000,data0 = salary,select = "CP",Yname = "log_salary",selection = "bidirection",Choose = "CP")

# 模型的分布为（根据所选变量分）
CPtable <- data.frame(frequncy=as.vector(table(rowSums(CPmodels[,-ncol(CPmodels)])))/1000,
                       complexity=as.numeric(names(table(rowSums(CPmodels[,-ncol(CPmodels)])))))
                       
ggplot(data = CPtable)+
  geom_histogram(mapping = aes(x = complexity,y = frequncy),stat = "identity",col="black",fill="lightblue")+
  theme_classic()+
  labs(title = "CP选择模型分布图")+
  theme(plot.title = element_text(hjust = 0.5))

datatable(CPmodels,width = "100%",options = list(scrollX=T))
```



```{r,message=FALSE,warning=FALSE,collapse=TRUE,cache=TRUE}
variate_percent_CP <- colSums(CPmodels[,-ncol(CPmodels)])/nrow(CPmodels)

datatable(data.frame(选入频率=variate_percent_CP))
```


可见：

1. **BIC法则**下模型的分布更为集中，更稳定；
2. 我们所确定的模型的变量入选频率均为前几，较为稳定。


```{r}
remove(list = ls())  # 清空环境
```


## 参考

[^1]:[How to Perform a Breusch-Pagan Test in R︎](https://www.statology.org/breusch-pagan-test-r/)



## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
